## 介绍
### query prediction task
在给定的知识图谱中，预测对于特定查询（query）所可能得到的答案或结果。这个任务关注于如何高效且准确地处理并回答那些涉及到图中未观测边（即知识图谱中尚未明确表示的关系）的复杂查询
query prediction task 的基本问题:
- **实体查询**：查询可能涉及寻找满足特定条件或关系的实体集合。例如，“哪些药物可以用来治疗特定疾病？”
- **关系查询**：这类查询关注于实体之间的特定类型的关系，例如，“哪些蛋白质与某种疾病有关联？”
- **路径查询**：查询可能涉及查找连接两个实体的路径，这些路径符合特定的关系序列。例如，“通过哪些中间蛋白质，某药物可以影响某疾病的发展？”
- **模式匹配查询**：这类查询寻找满足特定模式或结构的实体和关系的组合，例如，找到某种结构模式的生物化学反应网络。
多样性和实体间关系的复杂性，构成可能的查询的方式有很多种，且数量巨大。这种组合性来源于:
- **实体和关系的多样性**：知识图谱可能包含成千上万甚至更多的实体和关系，这些实体和关系可以以多种方式组合，形成不同的查询。
- **查询深度和宽度**：查询可以涉及不同数量的实体和关系，从简单的一跳（single-hop）查询到涉及多跳（multi-hop）的复杂查询，每增加一跳都会显著增加可能的查询数量。
- **逻辑结构的复杂性**：查询不仅可以请求特定的实体和关系，还可以包含逻辑运算（如与、或、非），进一步增加了可能的查询形式。

### conjunctive graph queries
通过 **析取** 多个条件来寻找满足所有这些条件的实体或实体组合
$$ q = V? . \exists V_1, \dots, V_m : e_1 \land e_2 \land \dots \land e_n $$
- $(V)$是我们要查询的目标变量（节点）。
- $(V_1, \dots, V_m)$是存在量化的变量，表示查询过程中可能涉及但不是最终目标的实体。
- $(e_1, e_2, \dots, e_n)$是一系列条件（edges或属性），它们连接了查询中的实体。
- stand conjunctive query language:最多只有一个变量
例如:$q=C_{?}.\exists P:ASSOC(d_{1},P)\wedge ASOC(d_{2},P))\wedge TATGET(P,C_{?})$
预测药物$C_{?}$可能靶向与给定疾病节点$d_1$和$d_{2}$相关的蛋白质
其中$d_1和d_2$ 是输入的信息
![[Pasted image 20240329174143.png]]

### dependency graph of a query
对于查询$q$，dependency graph of a query 是由anchor node $\{v_{1},\cdots v_{n}\}$，存在变量$\{V_{?},V_{1},\cdots ,V_{n}\}$，以及他们之间的边$\mathcal{E}_{q}=\{e_{1},\cdots ,e_{n}\}$ 构成的子图。
要使查询有效，其依赖关系图必须是有向无环图（DAG），锚节点是DAG的源节点，查询目标是唯一的sink节点。DAG结构确保没有矛盾或冗余。

### observed vs. unonbserved denotation sets:
对于查询$q\in \mathcal{Q(G)}$，存在带预测的未发现的表示集合$[q]$ ，假设这个集合在训练集中没有被完全观察到，因此为了，因此引入$[q]_{{train}}$来表示根据观察到的训练边，精确满足q的节点集。
训练集的组成是问答对$(q,v^{*}),v^{*}\in [q] _{train}$,。
通过训练数据来预测未被观测的数据 $(q,v^{ *}),v^{* },[q] \setminus [q]_{{train}}$

